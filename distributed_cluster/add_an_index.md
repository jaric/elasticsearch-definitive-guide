# 添加索引

爲了將數據添加到 Elasticsearch，我們需要 **索引(index)** —— 存儲關聯數據的地方。實際上，索引只是一個 **邏輯命名空間(logical namespace)**，它指向一個或多個 **分片(shards)**。

**分片(shard)** 是 **工作單元(worker unit)** 底層的一員，它只負責保存索引中所有數據的一小片。在接下來的《深入分片》一章中，我們還將深入學習分片是如何運作的，但是現在你只要知道分片是一個獨立的Lucene實例既可，並且它自身也是一個完整的搜索引擎。我們的文檔存儲並且被索引在分片中，但是我們的程序並不會直接與它們通信。取而代之，它們直接與索引進行通信的。

在 elasticsearch 中，分片用來分配集羣中的數據。把分片想象成一個數據的容器。數據被存儲在分片中，然後分片又被分配在集羣的節點上。當你的集羣擴展或者縮小時，elasticsearch 會自動的在節點之間遷移分配分片，以便集羣保持均衡。

分片分爲 **主分片(primary shard)** 以及 **從分片(replica shard)** 兩種。在你的索引中，每一個文檔都屬於一個主分片，所以具體有多少主分片取決於你的索引能存儲多少數據。

> 雖然理論上主分片對存儲多少數據是沒有限制的。分片的最大數量完全取決於你的實際狀況：硬件的配置、文檔的大小和複雜度、如何索引和查詢你的文檔，以及你期望的響應時間。

從分片只是主分片的一個副本，它用於提供數據的冗餘副本，在硬件故障時提供數據保護，同時服務於搜索和檢索這種只讀請求。

索引中的主分片的數量在索引創建後就固定下來了，但是從分片的數量可以隨時改變。

接下來，我們在空的單節點集羣中上創建一個叫做 `blogs` 的索引。一個索引默認設置了5個主分片，但是爲了演示，我們這裏只設置3個主分片和一組從分片（每個主分片有一個從分片對應）：

```Js
PUT /blogs
{
   "settings" : {
      "number_of_shards" : 3,
      "number_of_replicas" : 1
   }
}
```
現在，我們的集羣看起來就像下圖所示了**有索引的單節點集羣**，這三個主分片都被分配在 `Node 1`。

![有索引的單節點集羣](../images/02-02_one_node.png)

如果我們現在查看 **集羣健康(cluster-health)** ，我們將得到如下信息：

```Js
{
   "cluster_name":          "elasticsearch",
   "status":                "yellow", <1>
   "timed_out":             false,
   "number_of_nodes":       1,
   "number_of_data_nodes":  1,
   "active_primary_shards": 3,
   "active_shards":         3,
   "relocating_shards":     0,
   "initializing_shards":   0,
   "unassigned_shards":     3 <2>
}
```

1. 集羣的 `status` 爲 `yellow`.
2. 我們的三個從分片還沒有被分配到節點上。

集羣的健康狀況 `yellow` 意味着所有的 **主分片(primary shards)** 啓動並且運行了，這時集羣已經可以成功的處理任意請求，但是 **從分片(replica shards)** 沒有完全被激活。事實上，當前這三個從分片都處於 `unassigned`（未分配）的狀態，它們還未被分配到節點上。在同一個節點上保存相同的數據副本是沒有必要的，如果這個節點故障了，就等同於所有的數據副本也丟失了。

現在我們的集羣已經可用了，但是依舊存在因硬件故障而導致數據丟失的風險。
